# FLask

## 对蓝图(Blueprint)的理解？

**定义**：

蓝图是Flask应用程序组件化的方法，可以在一个应用内或跨越多个项目共用蓝图。使用蓝图可以极大简化大型应用的开发难度。



**应用场景**：

1.把一个应用分解为一个蓝图的集合。一个项目可以实例化一个应用对象，初始化几个扩展，注册一集合的蓝图。

2.以URL前缀或子域名，在应用上注册一个蓝图。URL 前缀/子域名中的参数即成为这个蓝图下的所有试图函数的共同的视图参数

3.在一个应用中用不同的URL 规则多次注册一个蓝图



**缺点**：

不能在应用创建后撤销注册一个蓝图而不销毁整个应用对象



**使用蓝图**：

1.创建一个蓝图对象

~~~~
blue = Blueprint("blue"，__name__)
~~~~

2.在这个蓝图对象上进行操作，例如注册路由、指定静态文件夹、注册模板过滤器...

~~~
@blue.route('/')
def blue_index():
	return 'Welcome to my blueprint'
~~~

3.在应用对象上注册这个蓝图对象

~~~
app.register_blueprint(blue，url_prefix='/blue')
~~~





# 内存管理与垃圾回收机制

## Python 的内存管理机制及调优手段？

**内存管理机制**：

引用计数、垃圾回收、内存池。

1. 引用计数
    引用计数也是一种垃圾收集机制，而且也是一种最直观，最简单的垃圾收集技术。当Python 的某
    个对象的引用计数降为0 时，说明没有任何引用指向该对象，该对象就成为要被回收的垃圾了。比如
    某个新建对象，它被分配给某个引用，对象的引用计数变为1。如果引用被删除，对象的引用计数为0，
    那么该对象就可以被垃圾回收。不过如果出现循环引用的话，引用计数机制就不再起有效的作用了

2. 标记清除
    如果两个对象的引用计数都为1，但是仅仅存在他们之间的循环引用，那么这两个对象都是需要被
    回收的，也就是说，它们的引用计数虽然表现为非0，但实际上有效的引用计数为0。所以先将循环引
    用摘掉，就会得出这两个对象的有效计数。

3. 分代回收
    从前面“标记-清除”这样的垃圾收集机制来看，这种垃圾收集机制所带来的额外操作实际上与系统
    中总的内存块的数量是相关的，当需要回收的内存块越多时，垃圾检测带来的额外操作就越多，而垃圾
    回收带来的额外操作就越少；反之，当需回收的内存块越少时，垃圾检测就将比垃圾回收带来更少的额
    外操作。

  举个例子：
  当某些内存块M 经过了3 次垃圾收集的清洗之后还存活时，我们就将内存块M 划到一个集合
  A 中去，而新分配的内存都划分到集合B 中去。当垃圾收集开始工作时，大多数情况都只对集合B 进
  行垃圾回收，而对集合A 进行垃圾回收要隔相当长一段时间后才进行，这就使得垃圾收集机制需要处
  理的内存少了，效率自然就提高了。在这个过程中，集合B 中的某些内存块由于存活时间长而会被转
  移到集合A 中，当然，集合A 中实际上也存在一些垃圾，这些垃圾的回收会因为这种分代的机制而
  被延迟。

4. 内存池：

   1. Python 的内存机制呈现金字塔形状，-1，-2 层主要有操作系统进行操作；
   2. 第0 层是C 中的malloc，free 等内存分配和释放函数进行操作；
   3. 第1 层和第2 层是内存池，有Python 的接口函数PyMem_Malloc 函数实现，当对象小于
       256K 时有该层直接分配内存；
   4. 第3 层是最上层，也就是我们对Python 对象的直接操作；
       Python 在运行期间会大量地执行malloc 和free 的操作，频繁地在用户态和核心态之间进行切
       换，这将严重影响Python 的执行效率。为了加速Python 的执行效率，Python 引入了一个内存池
       机制，用于管理对小块内存的申请和释放。
       Python 内部默认的小块内存与大块内存的分界点定在256 个字节，当申请的内存小于256 字节
       时，PyObject_Malloc 会在内存池中申请内存；当申请的内存大于256 字节时，PyObject_Malloc 的
       行为将蜕化为malloc 的行为。当然，通过修改Python 源代码，我们可以改变这个默认值，从而改
       变Python 的默认内存管理行为。

**调优手段**（了解）
1.手动垃圾回收

2.调高垃圾回收阈值

3.避免循环引用（手动解循环引用和使用弱引用）



## 内存泄露是什么？如何避免？

**指由于疏忽或错误造成程序未能释放已经不再使用的内存的情况**。内存泄漏并非指内存在物理上的消失，而是应用程序分配某段内存后，由于设计错误，失去了对该段内存的控制，**因而造成了内存的浪费。导致程序运行速度减慢甚至系统崩溃等严重后果**。
有__del__() 函数的对象间的循环引用是导致内存泄漏的主凶。

**避免**：

不使用一个对象时使用:del object 来删除一个对象的引用计数就可以有效防止内存泄漏问题。
通过Python 扩展模块gc 来查看不能回收的对象的详细信息。
可以通过sys.getrefcount(obj) 来获取对象的引用计数，并根据返回值是否为0 来判断是否内存
泄漏。





# 部署

## 有过部署经验？用的什么技术？可以满足多少压力？

1.有部署经验，在阿里云服务器上部署的
2.技术有：nginx + gunicorn的方式来部署Flask项目

3.无标准答案（例：压力测试一两千）



**gunicorn **:    ( /ˈɡɪnikɔːn/)

gunicorn是面向python WSGI应用的HTTP服务器。它在Linux上运行，优点是轻量级且速度快。gunicorn通过一个控制进程和多个工作进程来执行应用程序

命令：

~~~
# -w指定工作进程数量   
# flasky:app 告诉gunicorn应用实例的位置，冒号前面部分是实例所在包名或模块名，冒号后面部分是应用实例的名称
gunicorn -w 2 -b 127.0.0.0:8000 flasky:app


~~~



Ngnix**:

Ngnix是HTTP服务器、代理服务器等功能，轻量级且速度快。



现在在gunicorn上运行Flask应用， 然后通过ngnix进行反向代理，返回响应。  通过反向代理响应可以将Flask应用的服务器横向扩展成多个。

3.无标准答案（例：压力测试一两千）